// Prisma Schema - Ivan Reseller Database (PostgreSQL Version)
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ====================================
// MODELS
// ====================================

model User {
  id               Int       @id @default(autoincrement())
  username         String    @unique
  email            String    @unique
  password         String
  fullName         String?
  role             String    @default("USER") // "ADMIN" or "USER"
  commissionRate   Decimal   @default(0.20) @db.Decimal(6, 4) // Porcentaje de comisión sobre utilidad de operación exitosa (ej: 0.20 = 20%)
  fixedMonthlyCost Decimal   @default(0.00) @db.Decimal(18, 2) // Costo fijo mensual en USD (ej: 0.00 = sin costo fijo)
  balance          Decimal   @default(0) @db.Decimal(18, 2) // Balance del usuario en moneda base
  totalEarnings    Decimal   @default(0) @db.Decimal(18, 2) // Ganancias totales acumuladas en moneda base
  totalSales       Int       @default(0)
  isActive         Boolean   @default(true)
  lastLoginAt      DateTime?
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt
  createdBy            Int?     // ID del admin que creó este usuario (null si es admin o auto-creado)
  paypalPayoutEmail    String?  // Email PayPal para recibir ganancias (payouts)
  payoneerPayoutEmail  String?  // Email Payoneer para recibir pagos de eBay y otros marketplaces
  onboardingStep      Int      @default(0)
  onboardingCompleted Boolean  @default(false)
  ebayConnected       Boolean  @default(false)
  amazonConnected     Boolean  @default(false)
  mercadolibreConnected Boolean @default(false)

  // Relations
  products                Product[]
  sales                   Sale[]
  commissions             Commission[]
  apiCredentials          ApiCredential[]
  activities              Activity[]
  workflowConfig          UserWorkflowConfig?
  createdUsers            User[]                  @relation("UserCreator") // Usuarios creados por este admin
  creator                 User?                   @relation("UserCreator", fields: [createdBy], references: [id])
  adminCommissions        AdminCommission[] // Comisiones que recibe como admin de usuarios creados
  successfulOperations    SuccessfulOperation[] // Operaciones exitosas del usuario
  marketplaceListings     MarketplaceListing[]
  marketplacePublications MarketplacePublication[]
  opportunities           Opportunity[]
  aiSuggestions           AISuggestion[]
  manualAuthSessions      ManualAuthSession[]
  marketplaceAuthStatuses MarketplaceAuthStatus[]
  sharedCredentials       ApiCredential[]         @relation("SharedCredentialOwner")
  refreshTokens           RefreshToken[]
  passwordResetTokens     PasswordResetToken[]
  apiStatusHistory        APIStatusHistory[]
  apiStatusSnapshots      APIStatusSnapshot[]
  reportHistory           ReportHistory[]
  scheduledReports        ScheduledReport[]
  userSettings            UserSettings?
  accessRequestsReviewed  AccessRequest[]         @relation("AccessRequestReviewer") // Solicitudes de acceso revisadas por este admin
  autopilotWorkflows      AutopilotWorkflow[] // Workflows personalizados del usuario
  userMeetings            MeetingRoom[]           @relation("UserMeetings") // Reuniones iniciadas por el usuario
  adminMeetings           MeetingRoom[]           @relation("AdminMeetings") // Reuniones donde el usuario es admin
  orders                  Order[]                 // Órdenes de checkout (PayPal → AliExpress)
  purchaseLogs            PurchaseLog[] // Logs de compras automáticas

  @@index([email])
  @@index([username])
  @@index([role, isActive])
  @@index([createdAt])
  @@map("users")
}

// Platform-wide commission config (only ADMIN can change)
model PlatformConfig {
  id                     Int      @id @default(autoincrement())
  platformCommissionPct   Decimal  @db.Decimal(5, 2) @default(10.00) // Default 10%
  adminPaypalEmail        String
  updatedAt               DateTime @updatedAt

  @@map("platform_config")
}

model ApiCredential {
  id          Int             @id @default(autoincrement())
  userId      Int
  apiName     String // ebay, mercadolibre, amazon, paypal, groq, email, twilio, slack, stripe, etc.
  environment String          @default("production") // sandbox, production
  credentials String // JSON string with encrypted API keys
  isActive    Boolean         @default(true)
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt
  scope       CredentialScope @default(user)
  sharedById  Int?

  // Relations
  user     User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  sharedBy User? @relation("SharedCredentialOwner", fields: [sharedById], references: [id], onDelete: SetNull)

  @@unique([userId, apiName, environment, scope])
  @@index([userId, apiName, environment])
  @@index([apiName, environment, isActive])
  @@index([scope, isActive])
  @@map("api_credentials")
}

enum CredentialScope {
  user
  global
}

model Product {
  id              Int       @id @default(autoincrement())
  userId          Int
  aliexpressUrl   String
  title           String
  description     String?
  aliexpressPrice Decimal   @db.Decimal(18, 2) // Precio en AliExpress en moneda original
  suggestedPrice  Decimal   @db.Decimal(18, 2) // Precio sugerido de venta en moneda base
  finalPrice      Decimal?  @db.Decimal(18, 2) // Precio final (opcional) en moneda base
  currency        String    @default("USD") // Moneda original del precio de AliExpress (CLP, USD, EUR, etc.)
  category        String?
  images          String // JSON string with array of image URLs
  productData     String? // JSON string with full scraped data
  // ✅ MEJORADO: Costos adicionales para cálculo preciso de márgenes
  shippingCost    Decimal?  @db.Decimal(18, 2) // Costo de envío internacional en moneda base
  importTax       Decimal?  @db.Decimal(18, 2) // Impuestos de importación (IVA/aranceles) en moneda base
  totalCost       Decimal?  @db.Decimal(18, 2) // Costo total (producto + envío + impuestos) en moneda base
  targetCountry   String? // País destino para cálculo de impuestos (CL, ES, US, etc.)
  status          String    @default("PENDING") // PENDING, APPROVED, REJECTED, PUBLISHED, INACTIVE
  isPublished     Boolean   @default(false)
  publishedAt     DateTime?
  approvalId      String? // Marketplace approval ID
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  // Relations
  user                 User                  @relation(fields: [userId], references: [id], onDelete: Cascade)
  sales                Sale[]
  successfulOperations SuccessfulOperation[]
  marketplaceListings  MarketplaceListing[]
  marketplacePublications MarketplacePublication[]
  purchaseLogs         PurchaseLog[] // Logs de compras relacionadas

  @@index([userId, status])
  @@index([status, isPublished])
  @@index([createdAt])
  @@map("products")
}

model Sale {
  id               Int       @id @default(autoincrement())
  userId           Int
  productId        Int
  orderId          String    @unique
  marketplace      String // ebay, mercadolibre, amazon
  salePrice        Decimal   @db.Decimal(18, 2) // Precio de venta en moneda de venta
  aliexpressCost   Decimal   @db.Decimal(18, 2) // Costo en AliExpress en moneda base
  marketplaceFee   Decimal   @db.Decimal(18, 2) // Fee del marketplace en moneda de venta
  grossProfit        Decimal   @db.Decimal(18, 2) // Ganancia bruta en moneda de venta
  commissionAmount   Decimal   @db.Decimal(18, 2) // Comisión plataforma (admin) en moneda de venta
  netProfit          Decimal   @db.Decimal(18, 2) // Ganancia neta del usuario (grossProfit - commission) en moneda de venta
  currency           String    @default("USD") // Moneda de la venta (CLP, USD, EUR, etc.)
  status             String    @default("PENDING") // PENDING, PROCESSING, SHIPPED, DELIVERED, CANCELLED, RETURNED, PAYOUT_FAILED
  trackingNumber     String?
  isCompleteCycle    Boolean   @default(false) // Si completó ciclo completo sin devoluciones
  completedAt        DateTime? // Fecha de completado del ciclo
  adminPayoutId      String? // PayPal batch/item ID del payout al admin
  userPayoutId       String? // PayPal batch/item ID del payout al usuario

  // ✅ MEJORADO: Información del comprador
  buyerEmail      String? // Email del comprador (si está disponible)
  buyerName       String? // Nombre del comprador
  shippingAddress String? // Dirección completa de envío (JSON string o texto)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user                User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  product             Product              @relation(fields: [productId], references: [id], onDelete: Cascade)
  commission          Commission?
  adminCommissions    AdminCommission[]
  successfulOperation SuccessfulOperation? // Relación one-to-one con SuccessfulOperation
  purchaseLogs        PurchaseLog[] // Logs de compras relacionadas

  @@index([userId, status])
  @@index([marketplace, status])
  @@index([createdAt])
  @@index([orderId])
  @@map("sales")
}

model Commission {
  id            Int       @id @default(autoincrement())
  userId        Int
  saleId        Int       @unique
  amount        Decimal   @db.Decimal(18, 2) // Monto de la comisión en moneda de venta
  currency      String    @default("USD") // Moneda de la comisión (debe coincidir con Sale.currency)
  status        String    @default("PENDING") // PENDING, SCHEDULED, PAID, FAILED
  scheduledAt   DateTime?
  paidAt        DateTime?
  failureReason String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  sale Sale @relation(fields: [saleId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@index([userId, status])
  @@index([status, createdAt])
  @@map("commissions")
}

model Activity {
  id          Int      @id @default(autoincrement())
  userId      Int?
  action      String // login, logout, product_created, sale_completed, etc.
  description String
  ipAddress   String?
  userAgent   String?
  metadata    String? // JSON string with additional data
  createdAt   DateTime @default(now())

  // Relations
  user User? @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@index([action, createdAt])
  @@map("activities")
}

// ✅ CONFIGURACIÓN DE WORKFLOW POR USUARIO
model UserWorkflowConfig {
  id           Int    @id @default(autoincrement())
  userId       Int    @unique
  environment  String @default("sandbox") // sandbox, production
  workflowMode String @default("manual") // manual, automatic, hybrid

  // Configuración por etapa del dropshipping
  stageScrape          String @default("automatic") // manual, automatic, guided
  stageAnalyze         String @default("automatic") // manual, automatic, guided
  stagePublish         String @default("manual") // manual, automatic, guided
  stagePurchase        String @default("manual") // manual, automatic, guided
  stageFulfillment     String @default("manual") // manual, automatic, guided
  stageCustomerService String @default("manual") // manual, automatic, guided

  // Configuraciones de automatización
  autoApproveThreshold Float? // Confianza mínima para auto-aprobar
  autoPublishThreshold Float? // Confianza mínima para auto-publicar
  maxAutoInvestment    Decimal? @db.Decimal(18, 2) // Inversión máxima para auto-operaciones en moneda base
  workingCapital       Decimal  @default(500) @db.Decimal(18, 2) // Capital de trabajo disponible en PayPal (USD)
  minProfitUsd         Float? // Mínimo beneficio USD para publicar (override global)
  minRoiPct            Float? // Mínimo ROI % para publicar (override global)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_workflow_configs")
}

// ✅ CONFIGURACIÓN DE SETTINGS POR USUARIO
model UserSettings {
  id             Int    @id @default(autoincrement())
  userId         Int    @unique
  language       String @default("en") // en, es, pt, etc.
  timezone       String @default("America/New_York") // Timezone IANA
  dateFormat     String @default("MM/DD/YYYY") // MM/DD/YYYY, DD/MM/YYYY, etc.
  currencyFormat String @default("USD") // USD, EUR, GBP, CLP, MXN, BRL, etc.
  theme          String @default("light") // light, dark, auto

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_settings")
}

// ✅ COMISIONES DE ADMIN POR USUARIOS CREADOS
model AdminCommission {
  id             Int       @id @default(autoincrement())
  adminId        Int // ID del admin que recibe la comisión
  userId         Int // ID del usuario que generó la venta
  saleId         Int // ID de la venta que generó la comisión
  amount         Decimal   @db.Decimal(18, 2) // Monto de la comisión del admin en moneda de venta
  currency       String    @default("USD") // Moneda de la comisión (debe coincidir con Sale.currency)
  commissionType String    @default("user_sale") // user_sale, monthly_fee, etc.
  status         String    @default("PENDING") // PENDING, PAID, FAILED
  paidAt         DateTime?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  // Relations
  admin User @relation(fields: [adminId], references: [id], onDelete: Cascade)
  sale  Sale @relation(fields: [saleId], references: [id], onDelete: Cascade)

  @@map("admin_commissions")
}

// ✅ TRACKING DE OPERACIONES EXITOSAS (CICLOS COMPLETOS)
model SuccessfulOperation {
  id            Int    @id @default(autoincrement())
  userId        Int
  productId     Int
  saleId        Int    @unique // Una venta solo puede tener una operación exitosa registrada
  operationType String @default("full_cycle") // full_cycle, partial, etc.

  // Datos de la operación
  startDate      DateTime
  completionDate DateTime
  daysToComplete Int
  totalProfit    Decimal  @db.Decimal(18, 2) // Ganancia total en moneda base
  expectedProfit Decimal  @db.Decimal(18, 2) // Ganancia esperada en moneda base
  profitAccuracy Float // % de diferencia entre esperado y real

  // Estado de la operación
  hadReturns           Boolean @default(false)
  hadIssues            Boolean @default(false)
  issuesDescription    String?
  customerSatisfaction Int? // 1-5 rating

  // Datos de aprendizaje
  aiPredictionScore Float?
  aiConfidence      Float?
  actualSuccess     Boolean @default(true)
  learningPattern   String? // JSON con patrones identificados

  createdAt DateTime @default(now())

  // Relations
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)
  sale    Sale    @relation(fields: [saleId], references: [id], onDelete: Cascade)

  @@map("successful_operations")
}

// ✅ CONFIGURACIÓN DEL SISTEMA (SystemConfig)
model SystemConfig {
  id        Int      @id @default(autoincrement())
  key       String   @unique
  value     String // JSON string
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("system_configs")
}

// ✅ LISTINGS DE MARKETPLACE
model MarketplaceListing {
  id          Int       @id @default(autoincrement())
  productId   Int
  userId      Int
  marketplace String // ebay, mercadolibre, amazon
  listingId   String // ID del listing en el marketplace
  listingUrl  String?
  sku         String?
  publishedAt DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  // Relations
  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([marketplace, listingId])
  @@map("marketplace_listings")
}

model MarketplacePublication {
  id           Int      @id @default(autoincrement())
  productId    Int
  userId       Int
  marketplace  String
  listingId    String?
  publishStatus String
  publishedAt  DateTime?
  publishMode  String
  rawResponse  String?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, marketplace, publishStatus])
  @@index([productId, marketplace])
  @@map("marketplace_publications")
}

// ✅ OPORTUNIDADES DE NEGOCIO
model Opportunity {
  id                 Int      @id @default(autoincrement())
  userId             Int
  sourceMarketplace  String? // aliexpress, ebay, etc.
  sourceProductId    Int?
  title              String
  costUsd            Decimal  @db.Decimal(18, 2) // Costo base del producto
  // ✅ MEJORADO: Costos adicionales para cálculo preciso de márgenes
  shippingCost       Decimal? @db.Decimal(18, 2) // Costo de envío internacional en USD
  importTax          Decimal? @db.Decimal(18, 2) // Impuestos de importación (IVA/aranceles) en USD
  totalCost          Decimal? @db.Decimal(18, 2) // Costo total (producto + envío + impuestos) en USD
  targetCountry      String? // País destino para cálculo de impuestos (CL, ES, US, etc.)
  suggestedPriceUsd  Decimal  @db.Decimal(18, 2)
  profitMargin       Decimal  @db.Decimal(18, 2) // Margen basado en totalCost si está disponible
  roiPercentage      Decimal  @db.Decimal(18, 2) // ROI basado en totalCost si está disponible
  competitionLevel   String? // low, medium, high
  marketDemand       String? // low, medium, high
  confidenceScore    Decimal  @db.Decimal(5, 2)
  feesConsidered     String? // JSON
  targetMarketplaces String? // JSON array
  status             String   @default("PENDING") // PENDING, APPROVED, REJECTED, PUBLISHED
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  // Relations
  user                 User                  @relation(fields: [userId], references: [id], onDelete: Cascade)
  competitionSnapshots CompetitionSnapshot[]

  @@index([userId, status])
  @@index([status, createdAt])
  @@index([confidenceScore])
  @@map("opportunities")
}

// ✅ SNAPSHOTS DE COMPETENCIA
model CompetitionSnapshot {
  id               Int      @id @default(autoincrement())
  opportunityId    Int
  marketplace      String // ebay, mercadolibre, amazon
  region           String?
  currency         String?
  listingsFound    Int?
  averagePrice     Decimal? @db.Decimal(18, 2)
  minPrice         Decimal? @db.Decimal(18, 2)
  maxPrice         Decimal? @db.Decimal(18, 2)
  medianPrice      Decimal? @db.Decimal(18, 2)
  competitivePrice Decimal? @db.Decimal(18, 2)
  topListings      String? // JSON
  createdAt        DateTime @default(now())

  // Relations
  opportunity Opportunity @relation(fields: [opportunityId], references: [id], onDelete: Cascade)

  @@map("competition_snapshots")
}

// ✅ SUGERENCIAS IA
model AISuggestion {
  id              Int       @id @default(autoincrement())
  userId          Int
  type            String // pricing, inventory, marketing, listing, optimization, automation
  priority        String // high, medium, low
  title           String
  description     String
  impactRevenue   Decimal   @default(0) @db.Decimal(18, 2) // Impacto en ingresos en moneda base
  impactTime      Float     @default(0) // horas ahorradas
  difficulty      String // easy, medium, hard
  confidence      Float // 0-100
  actionable      Boolean   @default(true)
  implemented     Boolean   @default(false)
  implementedAt   DateTime?
  estimatedTime   String
  requirements    String? // JSON array
  steps           String? // JSON array
  relatedProducts String? // JSON array
  metrics         String? // JSON object { currentValue, targetValue, unit }
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, title])
  @@map("ai_suggestions")
}

model ManualAuthSession {
  id          Int       @id @default(autoincrement())
  token       String    @unique
  provider    String
  userId      Int
  status      String    @default("pending")
  cookies     Json?
  metadata    String? // JSON string with additional data (captchaUrl, pageUrl, etc.)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  expiresAt   DateTime?
  completedAt DateTime?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, provider, status])
  @@map("manual_auth_sessions")
}

model MarketplaceAuthStatus {
  id                   Int       @id @default(autoincrement())
  userId               Int       @map("user_id")
  marketplace          String
  status               String    @default("unknown")
  message              String?
  requiresManual       Boolean   @default(false) @map("requires_manual")
  lastAutomaticAttempt DateTime? @map("last_automatic_attempt")
  lastAutomaticSuccess DateTime? @map("last_automatic_success")
  createdAt            DateTime  @default(now()) @map("created_at")
  updatedAt            DateTime  @updatedAt @map("updated_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, marketplace])
  @@index([marketplace, status])
  @@map("marketplace_auth_status")
}

model RefreshToken {
  id        Int       @id @default(autoincrement())
  token     String    @unique
  userId    Int
  expiresAt DateTime
  createdAt DateTime  @default(now())
  revokedAt DateTime?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([token])
  @@index([expiresAt])
  @@map("refresh_tokens")
}

model PasswordResetToken {
  id        Int       @id @default(autoincrement())
  token     String    @unique
  userId    Int
  email     String
  expiresAt DateTime
  usedAt    DateTime?
  createdAt DateTime  @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([token])
  @@index([email])
  @@index([expiresAt])
  @@map("password_reset_tokens")
}

model APIStatusHistory {
  id             Int      @id @default(autoincrement())
  userId         Int
  apiName        String
  environment    String   @default("production")
  status         String // "healthy", "degraded", "unhealthy", "unknown"
  previousStatus String? // Estado anterior
  isAvailable    Boolean
  isConfigured   Boolean
  error          String?
  message        String?
  latency        Int? // Latencia en ms
  trustScore     Float?   @default(100.0) // Score de confianza 0-100
  changedAt      DateTime @default(now())
  createdAt      DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, apiName, environment])
  @@index([apiName, environment, status])
  @@index([changedAt])
  @@index([userId, changedAt])
  @@map("api_status_history")
}

model APIStatusSnapshot {
  id           Int      @id @default(autoincrement())
  userId       Int
  apiName      String
  environment  String   @default("production")
  status       String // "healthy", "degraded", "unhealthy", "unknown"
  isAvailable  Boolean
  isConfigured Boolean
  error        String?
  message      String?
  latency      Int?
  trustScore   Float    @default(100.0)
  lastChecked  DateTime @default(now())
  updatedAt    DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, apiName, environment])
  @@index([userId, apiName, environment])
  @@index([status, isAvailable])
  @@map("api_status_snapshots")
}

model ReportHistory {
  id           Int      @id @default(autoincrement())
  userId       Int
  reportType   String // "sales", "products", "users", "marketplace-analytics", "executive"
  reportFormat String // "json", "excel", "pdf", "html"
  fileName     String // Nombre del archivo generado
  fileSize     Int? // Tamaño del archivo en bytes (si está almacenado)
  filePath     String? // Ruta al archivo almacenado (si se guarda físicamente)
  filters      String? // JSON string con filtros aplicados
  summary      String? // JSON string con resumen del reporte
  status       String   @default("completed") // "pending", "processing", "completed", "failed"
  error        String? // Mensaje de error si falló
  generatedAt  DateTime @default(now())
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, reportType])
  @@index([userId, generatedAt])
  @@index([reportType, status])
  @@index([generatedAt])
  @@map("report_history")
}

model ScheduledReport {
  id            Int       @id @default(autoincrement())
  userId        Int
  reportType    String // "sales", "products", "users", "marketplace-analytics", "executive"
  reportFormat  String    @default("excel") // "json", "excel", "pdf", "html"
  scheduleType  String // "daily", "weekly", "monthly", "custom"
  scheduleValue String // Valor de la programación (ej: "08:00", "monday", "1")
  filters       String? // JSON string con filtros aplicados
  recipients    String? // JSON string con emails de destinatarios
  isActive      Boolean   @default(true)
  lastRunAt     DateTime? // Fecha de última ejecución
  nextRunAt     DateTime? // Fecha de próxima ejecución
  error         String? // Último error (si falló)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, isActive])
  @@index([isActive, nextRunAt])
  @@index([scheduleType])
  @@map("scheduled_reports")
}

// ✅ P0.5: Tabla para solicitudes de acceso (sistema de registro)
model AccessRequest {
  id              Int       @id @default(autoincrement())
  username        String
  email           String
  fullName        String?
  company         String?
  reason          String? // Razón por la que quiere acceso
  status          String    @default("PENDING") // "PENDING", "APPROVED", "REJECTED"
  reviewedBy      Int? // ID del admin que revisó la solicitud
  reviewedAt      DateTime?
  rejectionReason String? // Razón de rechazo (si aplica)
  notes           String? // Notas internas del admin
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  reviewer User? @relation("AccessRequestReviewer", fields: [reviewedBy], references: [id], onDelete: SetNull)

  @@unique([email])
  @@index([status])
  @@index([createdAt])
  @@index([reviewedBy])
  @@map("access_requests")
}

// ✅ WORKFLOWS PERSONALIZADOS DE AUTOPILOT
model AutopilotWorkflow {
  id          Int       @id @default(autoincrement())
  userId      Int
  name        String
  description String?
  type        String // search, analyze, publish, reprice, custom
  enabled     Boolean   @default(true)
  schedule    String? // Cron expression (ej: "0 */6 * * *" para cada 6 horas)
  conditions  Json? // JSON con condiciones para ejecutar el workflow
  actions     Json? // JSON con acciones a ejecutar
  lastRun     DateTime? // Última vez que se ejecutó
  nextRun     DateTime? // Próxima ejecución programada
  runCount    Int       @default(0) // Contador de ejecuciones
  logs        Json? // JSON array con logs de ejecuciones (últimos 50)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, enabled])
  @@index([userId, type])
  @@index([enabled, nextRun])
  @@index([nextRun])
  @@map("autopilot_workflows")
}

// ✅ LOGS DE CICLOS AUTOPILOT - Persist every cycle execution, decision, failure
model AutopilotCycleLog {
  id                    Int       @id @default(autoincrement())
  userId                Int
  cycleId               String    // Unique ID for this cycle run
  stage                 String    // trends, opportunity, pricing, publish, fulfillment
  success               Boolean   @default(false)
  message               String?
  opportunitiesFound    Int       @default(0)
  opportunitiesProcessed Int      @default(0)
  productsPublished     Int       @default(0)
  productsApproved      Int       @default(0)
  capitalUsed           Decimal   @default(0) @db.Decimal(18, 2)
  errors                Json?     // Array of error strings
  metadata              Json?     // Extra context
  durationMs            Int?
  createdAt             DateTime  @default(now())

  @@index([userId, createdAt])
  @@index([cycleId])
  @@index([stage])
  @@map("autopilot_cycle_logs")
}

// ✅ SALA DE REUNIONES (Meeting Room)
model MeetingRoom {
  id        Int       @id @default(autoincrement())
  roomId    String    @unique // ID único de la sala (ej: user-123-meeting)
  userId    Int // Usuario que inició/solicitó la reunión
  adminId   Int? // Admin que está en la reunión (null si no hay admin)
  status    String    @default("WAITING") // WAITING, ACTIVE, ENDED
  startedAt DateTime?
  endedAt   DateTime?
  duration  Int? // Duración en segundos
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  // Relations
  user  User  @relation("UserMeetings", fields: [userId], references: [id], onDelete: Cascade)
  admin User? @relation("AdminMeetings", fields: [adminId], references: [id], onDelete: SetNull)

  @@index([userId, status])
  @@index([adminId, status])
  @@index([status])
  @@index([roomId])
  @@map("meeting_rooms")
}

// ✅ LOGS DE COMPRAS AUTOMÁTICAS (Purchase Log)
model PurchaseLog {
  id        Int     @id @default(autoincrement())
  userId    Int
  saleId    Int? // ID de la venta relacionada (opcional)
  orderId   String? // ID de la orden en el marketplace
  productId Int? // ID del producto

  // Información de la compra
  supplierUrl    String // URL del proveedor (AliExpress, etc.)
  purchaseAmount Decimal @db.Decimal(18, 2) // Monto de la compra
  currency       String  @default("USD")
  quantity       Int     @default(1)

  // Resultado de la compra
  status       String  @default("PENDING") // PENDING, SUCCESS, FAILED, CANCELLED
  success      Boolean @default(false)
  errorMessage String? // Mensaje de error si falló

  // Información del proveedor
  supplierOrderId String? // ID de la orden en el proveedor
  trackingNumber  String? // Número de tracking

  // Validaciones realizadas
  capitalValidated Boolean  @default(false) // Si se validó capital antes de comprar
  capitalAvailable Decimal? @db.Decimal(18, 2) // Capital disponible al momento de la compra
  paypalValidated  Boolean  @default(false) // Si se validó saldo PayPal

  // Retry information
  retryAttempt Int @default(0) // Número de intento
  maxRetries   Int @default(3)

  // Timestamps
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  completedAt DateTime? // Cuando se completó (éxito o fallo final)

  // Relations
  user    User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  sale    Sale?    @relation(fields: [saleId], references: [id], onDelete: SetNull)
  product Product? @relation(fields: [productId], references: [id], onDelete: SetNull)

  @@index([userId, status])
  @@index([saleId])
  @@index([status, createdAt])
  @@index([createdAt])
  @@map("purchase_logs")
}

// ✅ Post-sale dropshipping: Order entity for PayPal checkout → AliExpress fulfillment
model Order {
  id                String   @id @default(cuid())
  userId            Int?     // Reseller que recibe la venta (para crear Sale automática tras fulfillment)
  productId         Int?
  title             String
  price             Decimal  @db.Decimal(18, 2)
  currency          String   @default("USD")
  customerName      String
  customerEmail     String
  shippingAddress   String   // JSON string
  status            String   @default("CREATED") // CREATED | PAID | PURCHASING | PURCHASED | FAILED
  paypalOrderId     String?
  aliexpressOrderId String?
  productUrl        String?
  errorMessage      String?  // Stored on FAILED
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  user User? @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([status])
  @@index([paypalOrderId])
  @@index([createdAt])
  @@index([userId])
  @@map("orders")
}

// Dynamic pricing history
model DynamicPriceLog {
  id               Int      @id @default(autoincrement())
  productId        Int?
  orderId          String?
  previousPriceUsd Decimal  @db.Decimal(18, 2)
  newPriceUsd      Decimal  @db.Decimal(18, 2)
  costUsd          Decimal  @db.Decimal(18, 2)
  competitorMinUsd Decimal? @db.Decimal(18, 2)
  competitorAvgUsd Decimal? @db.Decimal(18, 2)
  reason           String?
  createdAt        DateTime @default(now())

  @@index([productId])
  @@index([createdAt])
  @@map("dynamic_price_logs")
}

// Dynamic pricing history (spec: productId, oldPrice, newPrice, reason, createdAt)
model DynamicPriceHistory {
  id        Int      @id @default(autoincrement())
  productId Int
  oldPrice  Decimal  @db.Decimal(18, 2)
  newPrice  Decimal  @db.Decimal(18, 2)
  reason    String?
  createdAt DateTime @default(now())

  @@index([productId])
  @@index([createdAt])
  @@map("dynamic_price_history")
}

// Purchase attempt log (orderId, provider, success, error, createdAt)
model PurchaseAttemptLog {
  id        Int      @id @default(autoincrement())
  orderId   String
  provider  String
  success   Boolean
  error     String?
  createdAt DateTime @default(now())

  @@index([orderId])
  @@map("purchase_attempt_logs")
}

// Product performance (views, clicks, conversions, revenue)
model ProductPerformance {
  id          Int     @id @default(autoincrement())
  productId   Int     @unique
  category    String
  views       Int     @default(0)
  clicks      Int     @default(0)
  conversions Int     @default(0)
  revenue     Decimal @db.Decimal(18, 2) @default(0)

  @@index([category])
  @@map("product_performance")
}

// Account clustering (additive - existing ApiCredential unchanged)
model MarketplaceAccount {
  id            Int      @id @default(autoincrement())
  clusterId     Int
  userId        Int
  apiName       String
  credentialId  Int?
  isActive      Boolean  @default(true)
  isBlocked     Boolean  @default(false)
  lastHealthAt  DateTime?
  dailyUsage    Int      @default(0)
  maxDailyUsage Int      @default(100)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  cluster AccountCluster @relation(fields: [clusterId], references: [id], onDelete: Cascade)

  @@index([clusterId])
  @@map("marketplace_accounts")
}

model PayPalAccount {
  id            Int      @id @default(autoincrement())
  clusterId     Int
  identifier    String
  isActive      Boolean  @default(true)
  isBlocked     Boolean  @default(false)
  lastHealthAt  DateTime?
  dailyUsage    Int      @default(0)
  maxDailyUsage Int      @default(100)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  cluster AccountCluster @relation(fields: [clusterId], references: [id], onDelete: Cascade)

  @@index([clusterId])
  @@map("paypal_accounts")
}

model AliExpressAccount {
  id            Int      @id @default(autoincrement())
  clusterId     Int
  identifier    String
  isActive      Boolean  @default(true)
  isBlocked     Boolean  @default(false)
  lastHealthAt  DateTime?
  dailyUsage    Int      @default(0)
  maxDailyUsage Int      @default(100)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  cluster AccountCluster @relation(fields: [clusterId], references: [id], onDelete: Cascade)

  @@index([clusterId])
  @@map("aliexpress_accounts")
}

model AccountCluster {
  id        Int      @id @default(autoincrement())
  userId    Int
  name      String   @default("default")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  marketplaceAccounts MarketplaceAccount[]
  paypalAccounts      PayPalAccount[]
  aliexpressAccounts  AliExpressAccount[]

  @@index([userId])
  @@map("account_clusters")
}

// Learning engine scores
model LearningScore {
  id             Int      @id @default(autoincrement())
  userId         Int
  category       String
  priceRangeMin  Decimal  @db.Decimal(18, 2)
  priceRangeMax  Decimal  @db.Decimal(18, 2)
  conversionRate Decimal  @db.Decimal(8, 4)
  avgProfit      Decimal  @db.Decimal(18, 2)
  sampleCount    Int      @default(0)
  learningScore  Decimal  @db.Decimal(8, 4)
  updatedAt      DateTime @updatedAt

  @@unique([userId, category])
  @@index([userId])
  @@map("learning_scores")
}

// Modelo para almacenar tokens OAuth de AliExpress Affiliate API
model AliExpressToken {
  id           String   @id @default(cuid())
  accessToken  String // Token de acceso (encriptado)
  refreshToken String? // Refresh token (encriptado, si existe)
  expiresAt    DateTime // Fecha de expiración del access token
  tokenType    String   @default("Bearer")
  scope        String? // Scope del token
  state        String? // State usado en OAuth (para validación CSRF)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@index([expiresAt])
  @@map("aliexpress_tokens")
}

// Payoneer API account (platform-level for Mass Payout API)
model PayoneerAccount {
  id           Int       @id @default(autoincrement())
  userId       Int?      // null = platform account
  accountId    String    @unique // Payoneer program/partner ID
  accessToken  String?   // API token (encrypted in production)
  refreshToken String?
  expiresAt    DateTime?
  balance      Decimal?  @db.Decimal(18, 2)
  currency     String    @default("USD")
  isActive     Boolean   @default(true)
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  @@index([isActive])
  @@map("payoneer_accounts")
}
